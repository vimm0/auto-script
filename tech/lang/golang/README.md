##### Variable
- Variable Declaration
    - var foo int
    - var foo int = 42
    - foo := 42
- Redeclaration and Shadowing(overriding)
        - can not redeclare variables, but can shadow them
        - All variable must be used meaning, variable if used only be declared else not (built-in refactoring feature)
- Visibility
    - lower case first letter for package scope
    - upper case first letter to export
    - no private scope at all
- Naming Convention
    - Pascal or camelCase
        - Capitalize acronyms (HTTP, URL)
    - As short as reasonable
        - longer names for longer lives
- Type Conversions
    - destinationType(variable)
    - act as function conversion and convert in target value
    - use strconv package for strings conversion

##### Primitive
- Boolean Type
    - values are true or false
    - not an alias for other types(eg. int)
    - zero value is false
- Numeric Type
    - Integers
        - Signed Integer
            - int type has varying size, but min 32 bits
            - 8 bit(int8) through 64 bit(int64)
            - int8: 128 - 127
            - int16: 32768 - 32767
            - int32
            - int64
        - Unsigned Integer
            - 8bit(byte and uint8) through 32 bit(uint32)
            - uint8
            - uint16
            - uint32
        - Arithmetic Operator
            - Addition, Subtraction, Multiplication, Division, Reminder
        - Bitwise Operator
            - And, OR, XOR and NOT
        - zero value is zero
        - can't mix types in same family(uint64 + uint32= error)
    - Floating Point
        - Follow IEEE754 standard
        - zero value is 0
        - float32, float64
        - literal styles
            - decimal(3.45)
            - exponential(12e12 oe 2E10)
            - Mixed(13.7e12)
        - Arithmetic Operator
            - Addition, Subtraction, Multiplication, Division
    - Complex Number
        - zero value is (0+0i)
        - complex64
        - complex128
        - built-in functions
            - complex - make complex number from two floats
            - real - get real part as float
            - imag - get imaginary part as float
- Text Type
    - Strings
        - utf-8
        - immutable
        - can be concatenated with plus(+) operator
        - can be converted to []byte
    - Rune
        - utf-32
        - alias for int32
        - special method normally required to process
            - eg. strings, Reader#ReadRune        
##### Constant

- Naming convention
    - Immutable, but can be shadowed
    - Replaced by the compiler at compile time
        - Value must be calculable at compile time
    - Named like variables
        - PascalCase for exported constants
        - camelCase for internal constants
- Typed constants
    - Typed constants work like immutable variables
        - can interoperate only with same type
- Untyped constants
    - Untyped constant work like literals
        - can interoperate with similar types
- Enumerated constants
    - special symbol iota allows related constants to be created easily
    - Iota start at 0 in each const block and increments by one
    - watch out of constant value that match zero values for variables
- Enumerated expressions
    - Operations that can be determined at compile time are allowed
        - Arithmetic
        - Bitwise Operations
        - Bit shifting
        
##### Array and Slices
- Arrays
    - collection of items with same type
    - fixed size
    - declaration style
        - a := [3]int{1,2,3}
        - a := [...]int{1,2,3}
        - car a [3]int
    - Access via zero-based index
        - a := [3]int {1,2,3} // a[1] == 3
    - len function returns size of array
    - copies refer to different underlying data
- Slices
    - backed by array
    - Creation Stylle
        - slice existing array or slice
        - literal style
        - via make function
            - a:= make([]int, 10)
            - a:= make([]int, 10, 100)
        - len function return length of slice
        - cap function returns length of underlying array
        - append function to add elements to slice
            - may cause expensive copy operation if underlying array is too small
        - copies refer to same underlying array
        
##### Maps and Structs
- Maps
    - Collection of value types that are accessed via keys
    - Created via literals or via make function
    - Member accessed via [key] syntax
        - myMap["key"] = "value"
    - Check for presence with "value, ok" form of result
    - Multiple assignments refer to same underlying data
- Structs
    - Collection of disparate data types that describe a single concept
    - Keyed by named fields
    - Normally, created as types, but anonymous structs are allowed
    - Structs are value types
    - No inheritance, but can use composition via embedding
    - Tags can be added to struct fields to describe field
    
#### Control Flow 
##### (If and Switch Statement) 
- If statement
    - Initializer
    - Comparison operator
    - Logical operator
    - Short circuiting
    - If-else statements
    - If-else if statements
    - Equality and floats
- Switch statement
    - Switching on a tag
    - Cases with multiple tests
    - Initializers
    - Switches with no tag
    - Fallthrough (implicit break in go lang)
    - Type switches
    - Breaking out early (break in switch case)

##### Looping
    - For statement
        - simple loops
            - for initializer; test; incrementer {}
            - for test {}
            - for {}
        - exiting early
            - break
            - continue
            - labels
        - looping through collections
            - arrays, slice, maps, strings, channels
            - for k, v := range collection {}
##### Defer, Panic and Recovery
    - Defer
    - Panic
    - Recovery
    
###### Reference
- https://www.youtube.com/watch?v=YS4e4q9oBaU&t=1206s
